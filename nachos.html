<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Letter Portrait Generator (Simple)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin: 18px; color: #111; }
    label { display:block; margin-top:10px; }
    input[type="text"] { width:70px; font-size:16px; padding:4px; }
    input[type="number"] { width:80px; }
    button { margin-top:10px; padding:8px 12px; }
    canvas { border:1px solid #ccc; display:block; margin-top:12px; max-width:100%; height:auto; }
    pre { background:#f6f6f6; padding:8px; overflow:auto; max-height:220px; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  </style>
</head>
<body>

  <h2>Letter Portrait â€” Simple HTML</h2>

  <div>
    <label>Default image (uploaded):</label>
    <img id="preview" alt="preview" src="/mnt/data/74154586-39f0-4a53-aaaf-c7d63e1dbe52.png" style="max-width:240px; border:1px solid #ddd; display:block;"/>
  </div>

  <label class="row">
    <span>Or upload image:</span>
    <input id="file" type="file" accept="image/*" />
  </label>

  <label class="row">
    <span>Letter:</span>
    <input id="letter" type="text" maxlength="1" value="A" />
    <span>Columns (detail):</span>
    <input id="cols" type="number" min="20" max="400" value="120" />
    <span>Char height / width ratio (scale):</span>
    <input id="scale" type="number" step="0.05" value="0.55" />
  </label>

  <div class="row">
    <button id="generate">Generate Portrait</button>
    <button id="downloadPng">Download PNG</button>
    <button id="downloadTxt">Download Text</button>
  </div>

  <canvas id="outCanvas"></canvas>

  <h4>Text preview (first lines)</h4>
  <pre id="textPreview"></pre>

<script>
(function(){
  const defaultImageSrc = "/mnt/data/74154586-39f0-4a53-aaaf-c7d63e1dbe52.png";
  const fileInput = document.getElementById('file');
  const previewImg = document.getElementById('preview');
  const letterInput = document.getElementById('letter');
  const colsInput = document.getElementById('cols');
  const scaleInput = document.getElementById('scale');
  const generateBtn = document.getElementById('generate');
  const canvas = document.getElementById('outCanvas');
  const txtPreview = document.getElementById('textPreview');
  const downloadPngBtn = document.getElementById('downloadPng');
  const downloadTxtBtn = document.getElementById('downloadTxt');

  let currentImage = new Image();
  currentImage.crossOrigin = "anonymous";
  currentImage.src = defaultImageSrc;
  previewImg.src = defaultImageSrc;

  // if user uploads new file, use it
  fileInput.addEventListener('change', (e) => {
    const f = e.target.files && e.target.files[0];
    if (!f) return;
    const url = URL.createObjectURL(f);
    previewImg.src = url;
    currentImage.src = url;
  });

  // utility: draw letter portrait
  async function createLetterPortrait(img, options) {
    const letter = (options.letter || 'A')[0] || 'A';
    const cols = Math.max(10, Math.min(600, Math.floor(options.cols || 120)));
    const scale = Math.max(0.1, Math.min(5, options.scale || 0.55));
    const threshold = (typeof options.threshold === 'number') ? options.threshold : 0.92;

    // compute grid
    const W = img.naturalWidth || img.width;
    const H = img.naturalHeight || img.height;
    const cellWidth = W / cols;
    const cellHeight = cellWidth / scale;
    const rows = Math.max(1, Math.floor(H / cellHeight));

    // offscreen small canvas to sample brightness
    const small = document.createElement('canvas');
    small.width = cols;
    small.height = rows;
    const sctx = small.getContext('2d');
    // draw with cover-ish fit (preserve aspect by scaling to fit width)
    sctx.drawImage(img, 0, 0, cols, rows);

    const imageData = sctx.getImageData(0,0,cols,rows).data;

    // create text lines and compute canvas size
    const lines = [];
    for (let r=0; r<rows; r++){
      let rowChars = '';
      for (let c=0; c<cols; c++){
        const idx = (r*cols + c) * 4;
        const rpx = imageData[idx], gpx = imageData[idx+1], bpx = imageData[idx+2];
        const bw = (0.299*rpx + 0.587*gpx + 0.114*bpx) / 255; // brightness 0..1
        if (bw < threshold) {
          if (bw < 0.35) rowChars += letter.toUpperCase();
          else if (bw < 0.6) rowChars += letter.toLowerCase();
          else rowChars += letter;
        } else {
          rowChars += ' ';
        }
      }
      lines.push(rowChars);
    }

    // Render to canvas (text)
    // choose a monospaced font and compute character size
    const ctx = canvas.getContext('2d');
    // temporary measure text size using a hidden canvas
    const measureCanvas = document.createElement('canvas');
    const mctx = measureCanvas.getContext('2d');

    // pick a font size relative to cell height
    // char height = we set to 10..40 depending on rows
    // choose font size so canvas width = charWidth * cols fits reasonably
    let fontSize = Math.max(6, Math.min(32, Math.round(14 * (120 / cols))));
    mctx.font = `${fontSize}px "Courier New", monospace`;
    const metrics = mctx.measureText(letter);
    const charW = Math.ceil(metrics.width);
    const charH = Math.ceil(fontSize * 1.1);

    canvas.width = charW * cols;
    canvas.height = charH * rows;

    // white background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // draw each letter with grayscale color based on brightness
    for (let r=0; r<rows; r++){
      for (let c=0; c<cols; c++){
        const idx = (r*cols + c) * 4;
        const rpx = imageData[idx], gpx = imageData[idx+1], bpx = imageData[idx+2];
        const bw = (0.299*rpx + 0.587*gpx + 0.114*bpx) / 255;
        if (bw < threshold) {
          const fillVal = Math.round(bw * 255);
          ctx.fillStyle = `rgb(${fillVal},${fillVal},${fillVal})`;
          ctx.font = `${fontSize}px "Courier New", monospace`;
          const x = c * charW;
          const y = (r+1) * charH - Math.round(charH*0.18); // adjust baseline
          ctx.fillText(letter, x, y);
        }
      }
    }

    return { lines, canvasWidth: canvas.width, canvasHeight: canvas.height };
  }

  generateBtn.addEventListener('click', async () => {
    // ensure image is loaded
    if (!currentImage.complete) {
      await new Promise(res => currentImage.onload = res);
    }
    const opts = {
      letter: letterInput.value || 'A',
      cols: parseInt(colsInput.value,10) || 120,
      scale: parseFloat(scaleInput.value) || 0.55,
      threshold: 0.92
    };

    try {
      const result = await createLetterPortrait(currentImage, opts);
      // show text preview
      txtPreview.textContent = result.lines.slice(0, 20).join("\n");
    } catch (err) {
      alert("Error generating portrait: " + err.message);
      console.error(err);
    }
  });

  downloadPngBtn.addEventListener('click', () => {
    if (!canvas.width) { alert('Generate a portrait first.'); return; }
    const a = document.createElement('a');
    a.href = canvas.toDataURL('image/png');
    a.download = 'letter_portrait.png';
    a.click();
  });

  downloadTxtBtn.addEventListener('click', () => {
    if (!txtPreview.textContent) { alert('Generate first to get text output.'); return; }
    const fullText = txtPreview.textContent; // currently only first lines; to produce whole content we must regenerate lines
    // Better: regenerate full text quickly using same steps but output all lines
    // We'll regenerate using current settings to get full lines
    (async () => {
      if (!currentImage.complete) await new Promise(res => currentImage.onload = res);
      const opts = {
        letter: letterInput.value || 'A',
        cols: parseInt(colsInput.value,10) || 120,
        scale: parseFloat(scaleInput.value) || 0.55,
        threshold: 0.92
      };
      const result = await createLetterPortrait(currentImage, opts);
      const txt = result.lines.join("\n");
      const blob = new Blob([txt], {type: 'text/plain;charset=utf-8'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'letter_portrait.txt';
      a.click();
      setTimeout(()=>URL.revokeObjectURL(url), 2000);
    })();
  });

  // initial generate automatically after image loads to show something
  currentImage.onload = () => {
    previewImg.src = currentImage.src;
    generateBtn.click();
  };

})();
</script>

</body>
</html>
